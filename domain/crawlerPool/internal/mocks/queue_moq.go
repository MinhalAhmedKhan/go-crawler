// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"monzoCrawler/domain/crawlerPool"
	"sync"
)

// Ensure, that QueueMock does implement crawlerPool.Queue.
// If this is not the case, regenerate this file with moq.
var _ crawlerPool.Queue = &QueueMock{}

// QueueMock is a mock implementation of crawlerPool.Queue.
//
// 	func TestSomethingThatUsesQueue(t *testing.T) {
//
// 		// make and configure a mocked crawlerPool.Queue
// 		mockedQueue := &QueueMock{
// 			PopFunc: func() (interface{}, error) {
// 				panic("mock out the Pop method")
// 			},
// 			PushFunc: func(val interface{}) error {
// 				panic("mock out the Push method")
// 			},
// 			SizeFunc: func() uint64 {
// 				panic("mock out the Size method")
// 			},
// 		}
//
// 		// use mockedQueue in code that requires crawlerPool.Queue
// 		// and then make assertions.
//
// 	}
type QueueMock struct {
	// PopFunc mocks the Pop method.
	PopFunc func() (interface{}, error)

	// PushFunc mocks the Push method.
	PushFunc func(val interface{}) error

	// SizeFunc mocks the Size method.
	SizeFunc func() uint64

	// calls tracks calls to the methods.
	calls struct {
		// Pop holds details about calls to the Pop method.
		Pop []struct {
		}
		// Push holds details about calls to the Push method.
		Push []struct {
			// Val is the val argument value.
			Val interface{}
		}
		// Size holds details about calls to the Size method.
		Size []struct {
		}
	}
	lockPop  sync.RWMutex
	lockPush sync.RWMutex
	lockSize sync.RWMutex
}

// Pop calls PopFunc.
func (mock *QueueMock) Pop() (interface{}, error) {
	if mock.PopFunc == nil {
		panic("QueueMock.PopFunc: method is nil but Queue.Pop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPop.Lock()
	mock.calls.Pop = append(mock.calls.Pop, callInfo)
	mock.lockPop.Unlock()
	return mock.PopFunc()
}

// PopCalls gets all the calls that were made to Pop.
// Check the length with:
//     len(mockedQueue.PopCalls())
func (mock *QueueMock) PopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPop.RLock()
	calls = mock.calls.Pop
	mock.lockPop.RUnlock()
	return calls
}

// Push calls PushFunc.
func (mock *QueueMock) Push(val interface{}) error {
	if mock.PushFunc == nil {
		panic("QueueMock.PushFunc: method is nil but Queue.Push was just called")
	}
	callInfo := struct {
		Val interface{}
	}{
		Val: val,
	}
	mock.lockPush.Lock()
	mock.calls.Push = append(mock.calls.Push, callInfo)
	mock.lockPush.Unlock()
	return mock.PushFunc(val)
}

// PushCalls gets all the calls that were made to Push.
// Check the length with:
//     len(mockedQueue.PushCalls())
func (mock *QueueMock) PushCalls() []struct {
	Val interface{}
} {
	var calls []struct {
		Val interface{}
	}
	mock.lockPush.RLock()
	calls = mock.calls.Push
	mock.lockPush.RUnlock()
	return calls
}

// Size calls SizeFunc.
func (mock *QueueMock) Size() uint64 {
	if mock.SizeFunc == nil {
		panic("QueueMock.SizeFunc: method is nil but Queue.Size was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSize.Lock()
	mock.calls.Size = append(mock.calls.Size, callInfo)
	mock.lockSize.Unlock()
	return mock.SizeFunc()
}

// SizeCalls gets all the calls that were made to Size.
// Check the length with:
//     len(mockedQueue.SizeCalls())
func (mock *QueueMock) SizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSize.RLock()
	calls = mock.calls.Size
	mock.lockSize.RUnlock()
	return calls
}
