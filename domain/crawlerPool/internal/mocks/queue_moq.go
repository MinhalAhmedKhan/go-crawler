// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"monzoCrawler/domain/crawlerPool"
	"sync"
)

// Ensure, that FIFOQueueMock does implement crawlerPool.FIFOQueue.
// If this is not the case, regenerate this file with moq.
var _ crawlerPool.FIFOQueue = &FIFOQueueMock{}

// FIFOQueueMock is a mock implementation of crawlerPool.FIFOQueue.
//
// 	func TestSomethingThatUsesFIFOQueue(t *testing.T) {
//
// 		// make and configure a mocked crawlerPool.FIFOQueue
// 		mockedFIFOQueue := &FIFOQueueMock{
// 			PopFunc: func() (interface{}, error) {
// 				panic("mock out the Pop method")
// 			},
// 			PushFunc: func(val interface{}) error {
// 				panic("mock out the Push method")
// 			},
// 		}
//
// 		// use mockedFIFOQueue in code that requires crawlerPool.FIFOQueue
// 		// and then make assertions.
//
// 	}
type FIFOQueueMock struct {
	// PopFunc mocks the Pop method.
	PopFunc func() (interface{}, error)

	// PushFunc mocks the Push method.
	PushFunc func(val interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Pop holds details about calls to the Pop method.
		Pop []struct {
		}
		// Push holds details about calls to the Push method.
		Push []struct {
			// Val is the val argument value.
			Val interface{}
		}
	}
	lockPop  sync.RWMutex
	lockPush sync.RWMutex
}

// Pop calls PopFunc.
func (mock *FIFOQueueMock) Pop() (interface{}, error) {
	if mock.PopFunc == nil {
		panic("FIFOQueueMock.PopFunc: method is nil but FIFOQueue.Pop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPop.Lock()
	mock.calls.Pop = append(mock.calls.Pop, callInfo)
	mock.lockPop.Unlock()
	return mock.PopFunc()
}

// PopCalls gets all the calls that were made to Pop.
// Check the length with:
//     len(mockedFIFOQueue.PopCalls())
func (mock *FIFOQueueMock) PopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPop.RLock()
	calls = mock.calls.Pop
	mock.lockPop.RUnlock()
	return calls
}

// Push calls PushFunc.
func (mock *FIFOQueueMock) Push(val interface{}) error {
	if mock.PushFunc == nil {
		panic("FIFOQueueMock.PushFunc: method is nil but FIFOQueue.Push was just called")
	}
	callInfo := struct {
		Val interface{}
	}{
		Val: val,
	}
	mock.lockPush.Lock()
	mock.calls.Push = append(mock.calls.Push, callInfo)
	mock.lockPush.Unlock()
	return mock.PushFunc(val)
}

// PushCalls gets all the calls that were made to Push.
// Check the length with:
//     len(mockedFIFOQueue.PushCalls())
func (mock *FIFOQueueMock) PushCalls() []struct {
	Val interface{}
} {
	var calls []struct {
		Val interface{}
	}
	mock.lockPush.RLock()
	calls = mock.calls.Push
	mock.lockPush.RUnlock()
	return calls
}
