// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"io"
	"monzoCrawler/domain/crawler"
	"monzoCrawler/domain/models"
	"net/url"
	"sync"
)

// Ensure, that FetcherExtractorMock does implement crawler.FetcherExtractor.
// If this is not the case, regenerate this file with moq.
var _ crawler.FetcherExtractor = &FetcherExtractorMock{}

// FetcherExtractorMock is a mock implementation of crawler.FetcherExtractor.
//
// 	func TestSomethingThatUsesFetcherExtractor(t *testing.T) {
//
// 		// make and configure a mocked crawler.FetcherExtractor
// 		mockedFetcherExtractor := &FetcherExtractorMock{
// 			ExtractFunc: func(urlMoqParam *url.URL, contents io.Reader) (models.CrawlResult, error) {
// 				panic("mock out the Extract method")
// 			},
// 			FetchFunc: func(ctx context.Context, urlMoqParam *url.URL) (io.ReadCloser, error) {
// 				panic("mock out the Fetch method")
// 			},
// 		}
//
// 		// use mockedFetcherExtractor in code that requires crawler.FetcherExtractor
// 		// and then make assertions.
//
// 	}
type FetcherExtractorMock struct {
	// ExtractFunc mocks the Extract method.
	ExtractFunc func(urlMoqParam *url.URL, contents io.Reader) (models.CrawlResult, error)

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context, urlMoqParam *url.URL) (io.ReadCloser, error)

	// calls tracks calls to the methods.
	calls struct {
		// Extract holds details about calls to the Extract method.
		Extract []struct {
			// UrlMoqParam is the urlMoqParam argument value.
			UrlMoqParam *url.URL
			// Contents is the contents argument value.
			Contents io.Reader
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UrlMoqParam is the urlMoqParam argument value.
			UrlMoqParam *url.URL
		}
	}
	lockExtract sync.RWMutex
	lockFetch   sync.RWMutex
}

// Extract calls ExtractFunc.
func (mock *FetcherExtractorMock) Extract(urlMoqParam *url.URL, contents io.Reader) (models.CrawlResult, error) {
	if mock.ExtractFunc == nil {
		panic("FetcherExtractorMock.ExtractFunc: method is nil but FetcherExtractor.Extract was just called")
	}
	callInfo := struct {
		UrlMoqParam *url.URL
		Contents    io.Reader
	}{
		UrlMoqParam: urlMoqParam,
		Contents:    contents,
	}
	mock.lockExtract.Lock()
	mock.calls.Extract = append(mock.calls.Extract, callInfo)
	mock.lockExtract.Unlock()
	return mock.ExtractFunc(urlMoqParam, contents)
}

// ExtractCalls gets all the calls that were made to Extract.
// Check the length with:
//     len(mockedFetcherExtractor.ExtractCalls())
func (mock *FetcherExtractorMock) ExtractCalls() []struct {
	UrlMoqParam *url.URL
	Contents    io.Reader
} {
	var calls []struct {
		UrlMoqParam *url.URL
		Contents    io.Reader
	}
	mock.lockExtract.RLock()
	calls = mock.calls.Extract
	mock.lockExtract.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *FetcherExtractorMock) Fetch(ctx context.Context, urlMoqParam *url.URL) (io.ReadCloser, error) {
	if mock.FetchFunc == nil {
		panic("FetcherExtractorMock.FetchFunc: method is nil but FetcherExtractor.Fetch was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		UrlMoqParam *url.URL
	}{
		Ctx:         ctx,
		UrlMoqParam: urlMoqParam,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx, urlMoqParam)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedFetcherExtractor.FetchCalls())
func (mock *FetcherExtractorMock) FetchCalls() []struct {
	Ctx         context.Context
	UrlMoqParam *url.URL
} {
	var calls []struct {
		Ctx         context.Context
		UrlMoqParam *url.URL
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}
